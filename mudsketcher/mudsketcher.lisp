(in-package :mudsketcher)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defclass cairo-w (drawing-area)
    ((draw-fn :initform 'draw-clock-face :accessor cairo-w-draw-fn))
    (:metaclass gobject:gobject-class)))

(defparameter *src-location* (asdf:component-pathname (asdf:find-system :mudsketcher)))
(defparameter *edited-zone* (lispmud::load-zone (merge-pathnames "content/test.lzon" *src-location*)))
(defparameter *selected-room* nil)
(defparameter *debug-out* *standard-output*)

(defstruct name-keyword name keyword)

(defun hypot (x y)
  (sqrt (+ (* x x) (* y y))))

(defun initialize-model-and-combo-box (model combo-box list-of-strings)
  (store-add-column model "gchararray" #'identity)
  (iter (for i in list-of-strings)
	(store-add-item model i))
  (let ((renderer (make-instance 'cell-renderer-text :text "A text")))
    (cell-layout-pack-start combo-box renderer :expand t)
    (cell-layout-add-attribute combo-box renderer "text" 0))
  (setf (combo-box-model combo-box) model))

(defun run-mudsketcher ()
  (within-main-loop
    (let* (file-name
	   ;; GTK variables
	   (builder (let ((builder (make-instance 'builder)))
                      (builder-add-from-file
		       builder
		       (namestring (merge-pathnames "mudsketcher/mudsketcher.ui" *src-location*)))
		      builder))
	   (window (builder-get-object builder "window1"))
;	   (new-dialog (builder-get-object "dialog1"))
	   (new-action (builder-get-object builder "new"))
	   (open-action (builder-get-object builder "open"))
	   (save-action (builder-get-object builder "save"))
	   (save-as-action (builder-get-object builder "save-as"))
	   (zone-settings-action (builder-get-object builder "zone-settings"))
	   (disconnect-action (builder-get-object builder "disconnect"))
	   (h-box (builder-get-object builder "hbox1"))
	   (entry (builder-get-object builder "entry1"))
	   (text-view (builder-get-object builder "textview1"))
	   (combo-box (builder-get-object builder "combobox1"))
	   (model (make-instance 'array-list-store))
	   (mob-list (make-instance 'array-list-store))
	   (room-types '(:forest :indoors :city))
	   (room-type-names '("Лес" "Помещение" "Город"))
	   (room-classes '(lm:myroom lm:bank-room lm:shop-room lm:store-room lm:guild-room lm:hotel-room))
	   (room-class-model (make-instance 'array-list-store))
	   (room-class-names '("Обычная" "Банк" "Магазин" "Склад" "Гильдия" "Гостиница"))
	   (room-class-combo-box (builder-get-object builder "combobox-room-class"))
	   (room-class-options-button (builder-get-object builder "button-room-class-options"))
	   (canvas (make-instance 'zone-canvas :zone *edited-zone* :default-width 200 :default-height 200))
	   (drawing-area (builder-get-object builder "drawingarea1"))
	   (mob-list-view (builder-get-object builder "treeview2"))
	   (current-mob nil)
	   (f-change-mob-name nil)
	   (mob-hash (make-hash-table :test 'equal))
	   (mob-editor-name (builder-get-object builder "mob-name-entry"))
	   (mob-editor-enter-verb (builder-get-object builder "mob-enter-verb-entry"))
	   (mob-editor-leave-verb (builder-get-object builder "mob-leave-verb-entry"))
	   (mob-editor-animation-1 (builder-get-object builder "mob-animation-1-entry"))
	   (mob-editor-animation-2 (builder-get-object builder "mob-animation-2-entry"))
	   (mob-editor-animation-1-timer (builder-get-object builder "mob-animation-1-timer"))
	   (mob-editor-animation-2-timer (builder-get-object builder "mob-animation-2-timer"))
	   (mob-editor-move-interval (builder-get-object builder "move-interval-spinbutton"))
	   (mob-editor-type-combo-box (builder-get-object builder "combobox2"))
	   (mob-editor-type-names '("Обычный" "Банкир" "Продавец" "Кладовщик"))
	   (mob-editor-types '(:regular :banker :seller :storekeeper))
	   (mob-editor-type-model (make-instance 'array-list-store))
	   (mob-editor-optons-button (builder-get-object builder "button1"))
	   (add-mob-action (builder-get-object builder "add-mob"))
	   (remove-mob-action (builder-get-object builder "remove-mob"))
	   (mob-number-factory 0)
#+nil (make-instance 'drawing-area))
      (labels ((debug-out (str)
		 (setf (text-buffer-text (text-view-buffer text-view)) (format nil "~s" str)))
	       (initialize-new-dialog (d)
		 (let (;(entry (builder-get-object builder "zone-name-entry"))
		       (adj-y (builder-get-object builder "adjustment-y"))
		       (adj-x (builder-get-object builder "adjustment-x")))
		   (setf (adjustment-value adj-x) 6
			 (adjustment-value adj-y) 6))
		 (add-buttons-to-dialog d))
	       (new (&rest args)
		 (declare (ignore args))
		 (let ((d (builder-get-object builder "dialog1"))
		       (entry (builder-get-object builder "zone-name-entry"))
		       (adj-y (builder-get-object builder "adjustment-y"))
		       (adj-x (builder-get-object builder "adjustment-x")))
		   (widget-show d)
		   (when (eq :accept (dialog-run d))
		     (setf (zone canvas)
			   (make-instance 'lispmud::zone :name (entry-text entry)
					  :map-array (make-array (list (round (adjustment-value adj-y))
								       (round (adjustment-value adj-x)))
								 :adjustable t :initial-element nil)))
		     (full-update canvas))
		   (widget-hide d)))
	       (zone-settings (&rest args)
		 (declare (ignore args))
		 (let ((d (builder-get-object builder "dialog1"))
		       (entry (builder-get-object builder "zone-name-entry"))
		       (adj-y (builder-get-object builder "adjustment-y"))
		       (adj-x (builder-get-object builder "adjustment-x"))
		       (zone-map (lispmud::map-array *edited-zone*)))
		   (widget-show d)
		   (setf (adjustment-value adj-x) (array-dimension zone-map 1)
			 (adjustment-value adj-y) (array-dimension zone-map 0)
			 (entry-text entry) (lispmud::name *edited-zone*))
		   (when (eq :accept (dialog-run d))
		     (setf (name (zone canvas)) (entry-text entry)
			   (map-array (zone canvas)) (adjust-array zone-map (list (round (adjustment-value adj-y))
										  (round (adjustment-value adj-x)))
								   :initial-element nil))
		     (unlink-orphaned-rooms *edited-zone*)
		     (full-update canvas))
		   (widget-hide d)))
	       (cb-open (&rest args) (declare (ignore args))
                        (let ((d (make-instance 'file-chooser-dialog :action :open :title "Open file")))
                          (when file-name (setf (file-chooser-filename d) file-name))
                          (dialog-add-button d "gtk-cancel" :cancel)
                          (dialog-add-button d "gtk-open" :accept)
                          (when (eq :accept (dialog-run d))
                            (setf file-name (file-chooser-filename d)
				  (zone canvas) (load-zone file-name))
			    (iter (for i from (1- (store-items-count mob-list)) downto 0)
				  (store-remove-item mob-list (aref (gtk::store-items mob-list) i) :test #'string=))
			    (iter (for mob-spec in (mobs-spec (zone canvas)))
				  (for name = (getf mob-spec :name))
				  (store-add-item mob-list name)
				  (setf (gethash name mob-hash) mob-spec))
			    (full-update canvas))
			  (object-destroy d)))
               (save (&rest args) (declare (ignore args))
                     (if file-name
			 (progn
			   (save-mob-options current-mob)
			   (setf (mobs-spec (zone canvas)) (hash-table-values mob-hash))
			   (save-zone (zone canvas) file-name))
                         (save-as)))
               (save-as (&rest args) (declare (ignore args))
                        (let ((d (make-instance 'file-chooser-dialog :action :save :title "Save file")))
                          (when file-name (setf (file-chooser-filename d) file-name))
                          (dialog-add-button d "gtk-cancel" :cancel)
                          (dialog-add-button d "gtk-save" :accept)
                          (if (eq :accept (dialog-run d))
                              (progn
                                (setf file-name (file-chooser-filename d))
                                (object-destroy d)
                                (save))
                              (object-destroy d))))
	       (initialize-mob-list (m c)
		 (store-add-column m "gchararray" #'identity)
;		 (store-add-item m "Пиранья")
;		 (store-add-item m "Собака")
		 (let ((renderer (make-instance 'cell-renderer-text :text "A text")))
		   (cell-layout-pack-start c renderer :expand t)
		   (cell-layout-add-attribute c renderer "text" 0)))
	       (add-mob (&rest args)
		 (declare (ignore args))
		 (setf f-change-mob-name nil)
		 (let ((new-mob-id (format nil "new mob ~a" (incf mob-number-factory))))
		   (store-add-item mob-list new-mob-id)
		   (tree-view-set-cursor mob-list-view
					 (tree-model-path mob-list (tree-model-iter-first mob-list)))
		   (setf current-mob new-mob-id)
		   (setf (gethash new-mob-id mob-hash)
			 (list :name new-mob-id :type :regular))
		   (populate-mob-options new-mob-id)
		   (tree-view-set-cursor mob-list-view (tree-model-path mob-list (tree-model-iter-from-string mob-list (format nil "~A" (1- (store-items-count mob-list)))))))
		 (setf f-change-mob-name t))
	       (remove-mob (&rest args)
		 (declare (ignore args))
		 (when current-mob
		   (remhash current-mob mob-hash)
		   (store-remove-item mob-list current-mob :test #'string=)))
	       (mob-name-changed (entry)
		 (when f-change-mob-name
		   (let ((mob-plist (gethash current-mob mob-hash)))
		     (remhash current-mob mob-hash)
		     (setf current-mob (entry-text entry)
			   (getf mob-plist :name) current-mob
			   (gethash current-mob mob-hash) mob-plist))
		   ;; ACTUNG!!! FIXME!!!
		   (setf
		    (aref (gtk::store-items mob-list)
			  (parse-integer (tree-model-iter-to-string
					  mob-list
					  (tree-model-iter-by-path
					   mob-list
					   (tree-view-get-cursor mob-list-view)))))
		    (entry-text entry))
		   (widget-queue-draw mob-list-view)))
	       (change-edited-mob (tree-view)
		 (debug-out (hash-table-count mob-hash))
		 (when current-mob
		   (save-mob-options current-mob))
		 (setf current-mob (tree-model-item (tree-view-model tree-view)
						    (tree-view-get-cursor tree-view)))
		 (populate-mob-options current-mob))
	       (save-mob-options (mob-name)
		 (setf (gethash mob-name mob-hash)
		       (add-plist-to-plist (gethash mob-name mob-hash)
					   (list :name (entry-text mob-editor-name)
						 :enter-verb (entry-text mob-editor-enter-verb)
						 :leave-verb (entry-text mob-editor-leave-verb)
						 :move-interval (spin-button-value mob-editor-move-interval)
						 :animation-1 (entry-text mob-editor-animation-1)
						 :animation-2 (entry-text mob-editor-animation-2)
						 :animation-1-timer (spin-button-value mob-editor-animation-1-timer)
						 :animation-2-timer (spin-button-value mob-editor-animation-2-timer)))))
	       (populate-mob-options (mob-id)
		 (destructuring-bind
		       (&key name enter-verb leave-verb move-interval animation-1 animation-2
			     animation-1-timer animation-2-timer type &allow-other-keys)
		     (gethash mob-id mob-hash)
		   (setf (entry-text mob-editor-name) (or name "")
			 (entry-text mob-editor-enter-verb) (or enter-verb "")
			 (entry-text mob-editor-leave-verb) (or leave-verb "")
			 (spin-button-value mob-editor-move-interval) (or move-interval 0)
			 (entry-text mob-editor-animation-1) (or animation-1 "")
			 (entry-text mob-editor-animation-2) (or animation-2 "")
			 (spin-button-value mob-editor-animation-1-timer) (or animation-1-timer 0)
			 (spin-button-value mob-editor-animation-2-timer) (or animation-2-timer 0)
			 (combo-box-active mob-editor-type-combo-box) (or (position type mob-editor-types) 0))))
	       (mob-editor-type-changed (combo)
;		 (declare (ignore c))
		 (setf (getf (gethash current-mob mob-hash) :type)
		       (nth (combo-box-active combo) mob-editor-types))
		 (setf (widget-sensitive mob-editor-optons-button)
		       (/= 0 (combo-box-active combo))))
	       (room-type-changed (c)
		 (declare (ignore c))
		 (when-let* ((active (active-item canvas))
			     (current-room (canvas-item-draw-obj active)))
		   (setf (place-type current-room) (nth (combo-box-active combo-box) room-types))
		   (widget-queue-draw drawing-area)))
	       (room-class-changed (c)
		 (declare (ignore c))
		 (when-let* ((active (active-item canvas))
			     (current-room (canvas-item-draw-obj active)))
		   (setf (getf (editor-info current-room) :class) (nth (combo-box-active room-class-combo-box) room-classes))
		   (widget-queue-draw drawing-area)))
	       (room-select (room)
		 (setf (combo-box-active combo-box) (position (place-type room) room-types)
		       (entry-text entry) (LispMud::short-description room)
		       (text-buffer-text (text-view-buffer text-view)) (description room)
		       (combo-box-active room-class-combo-box) (position (print (get-class room) *debug-out*) room-classes)))
	       (room-unselect (room)
		 (setf (lispmud::short-description room) (entry-text entry)
		       (lispmud::description room) (text-buffer-text (text-view-buffer text-view))
		       (combo-box-active combo-box) (position (place-type room) room-types)
		       (combo-box-active room-class-combo-box) (position (get-class room) room-classes)
		       (entry-text entry) ""
		       (text-buffer-text (text-view-buffer text-view)) ""))
;	       (room-class-options (room)
;		 (if (eq lm:bank (get-class room))
;		     (when (eq :accept (dialog-run (builder-get-object builder "bank-options-dialog")))
;		       (setf (getf (editor-info room) :options)
;			     (list 
	       (disconnect-exits (&rest args)
		 (declare (ignore args))
		 (when (active-item canvas)
		   (let ((selected-room (canvas-item-draw-obj (active-item canvas)))
			 (zone-map (map-array (zone canvas))))
		     (destructuring-bind (selected-room-y selected-room-x)
			 (indexes-in-array zone-map selected-room)
		       (if (iter (for i in *exits*)
				 (if (exit selected-room i)
				     (leave t))
				 (finally nil))
			   (unlink selected-room)
			   (dolist (direction *exits*)
			     (let ((x1 (+ selected-room-x (dx-for-direction direction)))
				   (y1 (+ selected-room-y (dy-for-direction direction)))
				   room1)
			       (if (and (array-in-bounds-p zone-map y1 x1)
					(setf room1 (aref zone-map y1 x1)))
				   (setf (exit room1 (reverse-direction direction)) (make-instance 'exit :dest-room selected-room)
					 (exit selected-room direction) (make-instance 'exit :dest-room room1)))))))
		     (regenerate-exits canvas)
		     (widget-queue-draw drawing-area)))))
	(initialize-new-dialog (builder-get-object builder "dialog1"))
	(add-buttons-to-dialog (builder-get-object builder "banker-mob-options-dialog"))
	(initialize-model-and-combo-box model combo-box room-type-names)
	(initialize-model-and-combo-box room-class-model room-class-combo-box room-class-names)
	(initialize-model-and-combo-box mob-editor-type-model mob-editor-type-combo-box mob-editor-type-names)
	(connect-signal combo-box "changed" #'room-type-changed)
	(connect-signal room-class-combo-box "changed" #'room-class-changed)
	(connect-signal mob-editor-type-combo-box "changed" #'mob-editor-type-changed)
	(connect-signal mob-editor-optons-button "clicked"
			#'(lambda (b) (declare (ignore b))
				  (setf (gethash current-mob mob-hash)
					(run-special-mob-dialog builder "banker-mob-options-dialog"
								(gethash current-mob mob-hash)
								'(:deposit-phrase "deposit-phrase-textview"
								  :withdraw-phrase "withdraw-phrase-textview")))))
	(box-pack-start h-box drawing-area)
	(connect-signal new-action  "activate" #'new)
	(connect-signal open-action "activate" #'cb-open)
	(connect-signal save-action "activate" #'save)
	(connect-signal save-as-action "activate" #'save-as)
	(connect-signal zone-settings-action "activate" #'zone-settings)
	(connect-signal disconnect-action "activate" #'disconnect-exits)
	(connect-signal add-mob-action "activate" #'add-mob)
	(connect-signal remove-mob-action "activate" #'remove-mob)
	(initialize-mob-list mob-list mob-list-view)
	(setf (tree-view-model mob-list-view) mob-list)
	(connect-signal mob-list-view "cursor-changed" #'change-edited-mob)
	(connect-signal mob-editor-name "changed" #'mob-name-changed)
	
#+nil	(connect-signal window "key-press-event"
			(lambda (&rest args)
				(format *myout* "~{~a~%~}~%" args)))
	(connect-canvas-signals canvas drawing-area :draw-mode :room-classes)
	(setf (select-cb canvas) #'room-select)
	(setf (unselect-cb canvas) #'room-unselect)
	(widget-show window)))))

  (defun rounded-rectangle (x y w h r)
  (let* ((x0 (+ x r))
	 (y0 (+ y r))
	 (x1 (+ x w (- r)))
	 (y1 (+ y h (- r))))
    (arc x0 y0 r (deg-to-rad 180) (deg-to-rad 270))
    (arc x1 y0 r (deg-to-rad 270) (deg-to-rad 360))
    (arc x1 y1 r (deg-to-rad 0)   (deg-to-rad 90))
    (arc x0 y1 r (deg-to-rad 90)  (deg-to-rad 180))
    (fill-path)))

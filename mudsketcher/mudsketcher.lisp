(in-package :mudsketcher)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defclass cairo-w (drawing-area)
    ((draw-fn :initform 'draw-clock-face :accessor cairo-w-draw-fn))
    (:metaclass gobject:gobject-class)))

(defvar *coord* '(0 0))
(defparameter *src-location* (asdf:component-pathname (asdf:find-system :mudsketcher)))
(defparameter *edited-zone* (lispmud::load-zone (merge-pathnames "content/1.lzon" *src-location*)))
(defparameter *selected-room* nil)

(defstruct name-keyword name keyword)

(defun hypot (x y)
  (sqrt (+ (* x x) (* y y))))

(defun run-mudsketcher ()
  (within-main-loop
    (let* (x
	   y
	   *selected-room*
	   selected-room-x
	   selected-room-y
	   (last-click-time -10000)
	   (last-click-x -10000)
	   (last-click-y -10000)
	   file-name
	   ;; GTK variables
	   (builder (let ((builder (make-instance 'builder)))
                      (builder-add-from-file builder (namestring (merge-pathnames "mudsketcher/mudsketcher.ui" *src-location*)))
		      builder))
	   (window (builder-get-object builder "window1"))
;	   (new-dialog (builder-get-object "dialog1"))
	   (new-action (builder-get-object builder "new"))
	   (open-action (builder-get-object builder "open"))
	   (save-action (builder-get-object builder "save"))
	   (save-as-action (builder-get-object builder "save-as"))
	   (zone-settings-action (builder-get-object builder "zone-settings"))
	   (disconnect-action (builder-get-object builder "disconnect"))
	   (h-box (builder-get-object builder "hbox1"))
	   (entry (builder-get-object builder "entry1"))
	   (text-view (builder-get-object builder "textview1"))
	   (combo-box (builder-get-object builder "combobox1"))
	   (model (make-instance 'array-list-store))
	   (room-types '(:forest :indoors :city))
	   (room-type-names '("Лес" "Помещение" "Город"))
	   (canvas (make-instance 'zone-canvas :zone *edited-zone* :default-width 200 :default-height 200))
	   (cw (make-instance 'cairo-w)))
      (labels ((debug-out (str)
		 (setf (text-buffer-text (text-view-buffer text-view)) str))
	       (initialize-new-dialog (d)
		 (let (;(entry (builder-get-object builder "zone-name-entry"))
		       (adj-y (builder-get-object builder "adjustment-y"))
		       (adj-x (builder-get-object builder "adjustment-x")))
		   (setf (adjustment-value adj-x) 6
			 (adjustment-value adj-y) 6))
		 (dialog-add-button d "gtk-cancel" :cancel)
		 (dialog-add-button d "gtk-new" :accept))
	       (new (&rest args)
		 (declare (ignore args))
		 (let ((d (builder-get-object builder "dialog1"))
		       (entry (builder-get-object builder "zone-name-entry"))
		       (adj-y (builder-get-object builder "adjustment-y"))
		       (adj-x (builder-get-object builder "adjustment-x")))
		   (widget-show d)
		   (when (eq :accept (dialog-run d))
		     (setf *edited-zone* (make-instance 'lispmud::zone :name (entry-text entry)
							:map-array (make-array (list (round (adjustment-value adj-y))
										     (round (adjustment-value adj-x)))
									       :adjustable t :initial-element nil)))
		     ;; TODO : set canvas zone.
		     )
		   (widget-hide d)))
	       (zone-settings (&rest args)
		 (declare (ignore args))
		 (let ((d (builder-get-object builder "dialog1"))
		       (entry (builder-get-object builder "zone-name-entry"))
		       (adj-y (builder-get-object builder "adjustment-y"))
		       (adj-x (builder-get-object builder "adjustment-x"))
		       (zone-map (lispmud::map-array *edited-zone*)))
		   (widget-show d)
		   (setf (adjustment-value adj-x) (array-dimension zone-map 1)
			 (adjustment-value adj-y) (array-dimension zone-map 0)
			 (entry-text entry) (lispmud::name *edited-zone*))
		   (when (eq :accept (dialog-run d))
		     (setf (lispmud::name *edited-zone*) (entry-text entry)
			   (lispmud::map-array *edited-zone*) (adjust-array zone-map (list (round (adjustment-value adj-y))
											   (round (adjustment-value adj-x)))
									    :initial-element nil))
		     ;; TODO: Updte canvas.
		     (unlink-orphaned-rooms *edited-zone*))
		   (widget-hide d))
		 (widget-queue-draw cw))
	       (cb-open (&rest args) (declare (ignore args))
                        (let ((d (make-instance 'file-chooser-dialog :action :open :title "Open file")))
                          (when file-name (setf (file-chooser-filename d) file-name))
                          (dialog-add-button d "gtk-cancel" :cancel)
                          (dialog-add-button d "gtk-open" :accept)
                          (when (eq :accept (dialog-run d))
                            (setf file-name (file-chooser-filename d)
				  *edited-zone* (load-zone file-name)))
			  ;; TODO: update canvas
			  (object-destroy d)))
               (save (&rest args) (declare (ignore args))
                     (if file-name
			 (save-zone *edited-zone* file-name)
                         (save-as)))
               (save-as (&rest args) (declare (ignore args))
                        (let ((d (make-instance 'file-chooser-dialog :action :save :title "Save file")))
                          (when file-name (setf (file-chooser-filename d) file-name))
                          (dialog-add-button d "gtk-cancel" :cancel)
                          (dialog-add-button d "gtk-save" :accept)
                          (if (eq :accept (dialog-run d))
                              (progn
                                (setf file-name (file-chooser-filename d))
                                (object-destroy d)
                                (save))
                              (object-destroy d))))
	       (initialize-model-and-combo-box (m c)
		 (store-add-column m "gchararray" #'identity)
		 (iter (for i in room-type-names)
		       (store-add-item m i))
		 (let ((renderer (make-instance 'cell-renderer-text :text "A text")))
		   (cell-layout-pack-start c renderer :expand t)
		   (cell-layout-add-attribute c renderer "text" 0)))
	       (room-type-changed (c)
		 (declare (ignore c))
		 (if *selected-room*
		     (setf (lispmud::place-type *selected-room*) (nth (combo-box-active combo-box) room-types)))
		 (widget-queue-draw cw))
	       (move-selected-room-to (new-x new-y)
		 (unless (aref (lispmud::map-array *edited-zone*) new-y new-x)
		   (setf (aref (lispmud::map-array *edited-zone*) selected-room-y selected-room-x) nil)
		   (setf (aref (lispmud::map-array *edited-zone*) new-y new-x) *selected-room*
			 selected-room-x new-x
			 selected-room-y new-y)))
	       (motion-notify-event (widget event &rest args)
		 (declare (ignore widget args))
		 (if (and (member :button1-mask (event-motion-state event)) *selected-room*)
		     (multiple-value-bind (w h) (gdk:drawable-get-size (widget-window cw))
		       (unlink *selected-room*)
		       (apply #'move-selected-room-to (nearest-cell (clamp (event-motion-x event) 0 w)
								    (clamp (event-motion-y event) 0 h)
								    w h))
		       (widget-queue-draw cw))
		     (progn
		       (setf x (event-motion-x event)
			     y (event-motion-y event))
		       (setf *coord* (list x y))
		       (widget-queue-draw cw))))
	       (button-press-event (widget event)
		 (declare (ignore widget))
		 (let ((click-x (event-button-x event))
		       (click-y (event-button-y event))
		       (click-time (event-button-time event))
		       new-selected-room)
		   (multiple-value-bind (w h) (gdk:drawable-get-size (widget-window cw))
		     (if (and (< (- click-time last-click-time) 1000) (= click-x last-click-x) (= click-y last-click-y)
			      (not (select-room click-x click-y w h)))
			 ;; THEN: double click
			 (destructuring-bind (x y) (nearest-cell-to-point (event-button-x event) (event-button-y event) w h)
			   (setf new-selected-room
				 (setf (aref (lispmud::map-array *edited-zone*) y x) (make-instance 'myroom :place-type :forest))))
			 ;; ELSE: single click
			 (multiple-value-bind (room room-x room-y)
			     (select-room (event-button-x event) (event-button-y event) w h)
			   (when (and *selected-room* (not (eql room *selected-room*)))
			     (setf (lispmud::short-description *selected-room*) (entry-text entry))
			     (setf (lispmud::description *selected-room*) (text-buffer-text (text-view-buffer text-view))))
			   (setf *selected-room* room
				 selected-room-x room-x
				 selected-room-y room-y))))
		   (if *selected-room*
		       (progn
			 (setf (combo-box-active combo-box) (position (place-type *selected-room*) room-types))
			 (setf (entry-text entry) (LispMud::short-description *selected-room*))
			 (setf (text-buffer-text (text-view-buffer text-view)) (description *selected-room*)))
		       (progn
			 (setf (combo-box-active combo-box) -1)
			 (setf (entry-text entry) "")
			 (setf (text-buffer-text (text-view-buffer text-view)) "")))
		   (setf last-click-time click-time
			 last-click-x click-x
			 last-click-y click-y))
;		 (debug-out (format nil "~a" event)) ;; ~~~~
		 (widget-queue-draw cw))
	       (disconnect-exits (&rest args)
		 (declare (ignore args))
		 (when *selected-room*
		   (if (iter (for i in *exits*)
			     (if (exit *selected-room* i)
				 (leave t))
			     (finally nil))
		       (unlink *selected-room*)
#+nil		       (iter (for i in *exits*)
			     (when (exit *selected-room* i)
			       (setf (exit (dest-room (exit *selected-room* i)) (reverse-direction i)) nil)
			       (setf (exit *selected-room* i) nil)))
;			       (setf (exit (exit *selected-room* i) (reverse-direction i)) nil)
;			       (setf (exit *selected-room* i) nil)))

		       (dolist (direction *exits*)
			 (let ((x1 (+ selected-room-x (dx-for-direction direction)))
			       (y1 (+ selected-room-y (dy-for-direction direction)))
			       (zone-map (lispmud::map-array *edited-zone*))
			       room1)
			   (if (and (array-in-bounds-p zone-map y1 x1)
				    (setf room1 (aref zone-map y1 x1)))
			       (setf (exit room1 (reverse-direction direction)) (make-instance 'exit :dest-room *selected-room*)
				     (exit *selected-room* direction) (make-instance 'exit :dest-room room1)))))))
		 (widget-queue-draw cw))
)
	(initialize-new-dialog (builder-get-object builder "dialog1"))
	(initialize-model-and-combo-box model combo-box)
	(setf (combo-box-model combo-box) model)
	(connect-signal combo-box "changed" #'room-type-changed)
	(box-pack-start h-box cw)
	(connect-signal new-action  "activate" #'new)
	(connect-signal open-action "activate" #'cb-open)
	(connect-signal save-action "activate" #'save)
	(connect-signal save-as-action "activate" #'save-as)
	(connect-signal zone-settings-action "activate" #'zone-settings)
	(connect-signal disconnect-action "activate" #'disconnect-exits)
	(connect-signal cw "realize"
			(lambda (widget)
			  (declare (ignore widget))
			  (pushnew :pointer-motion-mask (gdk-window-events (widget-window cw)))
			  (pushnew :button-press-mask (gdk-window-events (widget-window cw)))))
#+nil	(connect-signal window "key-press-event"
			(lambda (&rest args)
			  (setf (text-buffer-text (text-view-buffer text-view))
				(format nil "~{~a ~}" args))))
	(connect-signal cw "motion-notify-event" #'motion-notify-event)
	(connect-signal cw "button_press_event" #'button-press-event)
	(setf (cairo-w-draw-fn cw) 'draw-zone-map)
	(widget-show window)))))

#+nil
(defun nearest-cell (x0 y0 w h)
  (let* ((map (lispmud::map-array *edited-zone*))
	 (x-dim (array-dimension map 1))
	 (w (* x-dim (round w (* 2 x-dim)) 2))
	 (x-grid-step (/ w x-dim))
	 (y-dim (array-dimension map 0))
	 (h (* y-dim (round h (* 2 y-dim)) 2))
	 (y-grid-step (/ h y-dim)))
    (let ((dx (* x-grid-step 0.5))
	  (dy (* y-grid-step 0.5)))
      (list (round (- x0 dx) x-grid-step)
	    (round (- y0 dy) y-grid-step)))))

#+nil
(defun nearest-cell-to-point (x0 y0 w h)
  (let* ((map (lispmud::map-array *edited-zone*))
	 (x-dim (array-dimension map 1))
	 (w (* x-dim (round w (* 2 x-dim)) 2))
	 (x-grid-step (/ w x-dim))
	 (y-dim (array-dimension map 0))
	 (h (* y-dim (round h (* 2 y-dim)) 2))
	 (y-grid-step (/ h y-dim)))
    (flet ((x-coord (x) (* x-grid-step (+ 0.5 x)))
	   (y-coord (y) (* y-grid-step (+ 0.5 y))))
      (iter (for x from 0 below x-dim)
	    (iter (for y from 0 below y-dim)
		  (when (< (hypot (- x0 (x-coord x)) (- y0 (y-coord y))) 20)
		    (return-from nearest-cell-to-point (list x y))))))
    '(nil nil)))

#+nil
(defun select-room (x0 y0 w h)
  (destructuring-bind (x y) (nearest-cell-to-point x0 y0 w h)
    (let ((map (lispmud::map-array *edited-zone*)))
      (when (and x y (aref map y x))
	(values (aref map y x) x y)))))

(defun rounded-rectangle (x y w h r)
  (let* ((x0 (+ x r))
	 (y0 (+ y r))
	 (x1 (+ x w (- r)))
	 (y1 (+ y h (- r))))
    (arc x0 y0 r (deg-to-rad 180) (deg-to-rad 270))
    (arc x1 y0 r (deg-to-rad 270) (deg-to-rad 360))
    (arc x1 y1 r (deg-to-rad 0)   (deg-to-rad 90))
    (arc x0 y1 r (deg-to-rad 90)  (deg-to-rad 180))
    (fill-path)))

